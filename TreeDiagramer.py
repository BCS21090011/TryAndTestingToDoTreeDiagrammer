'''
I'm not a good coder, so please do not expect too much from me.

Properties in TreeDiagramer:
    OriDataset: pandas.DataFrame
        Will store the original (won't be modified) dataset.

    Dataset: pandas.DataFrame
        Will store the dataset (will be modified).

    OneHotDataVal: dict
        Will store all the changes made by OneHotMapping() method.

    DataValRepresentation: dict
        Will store all the changes made by Mapping() method.

    Features: list[str]
        Will store all the columns (not the encoded columns after OneHotMapping()).

    Output: pandas.Series
        Store the output column.

    TreeDgrm: sklearn.tree.DecisionTreeClassifier
        Dunno. It is the part that make all the predictions etc.

Methods in TreeDiagramer:
    __init__:
        Arguments:
            Required: dataset (pandas.DataFrame)
        Will take dataset (required) and assign it to OriDataset and Dataset.

    OneHotMapping:
        Arguments:
            Required: columnsToApply (list[str])
        Will apply One-Hot encode for the column you gave to the Dataset if all the values in the column is not
        numeric. Will store the encoded column names in OneHotDataVal. When apply OneHotMapping() to a column, the
        encoded columns will move (actually will drop and join) to the end (right most columns) and same with it's
        corresponding column name in Features.

    Mapping:
        Arguments:
            Required: columnsToApply (list[str])
        If all the values in the column you gave is not numeric, it will assign an int for each value, store the value
        and it's corresponding int assigned in DataValRepresentation, and map the Dataset. I don't know which int will
        assign to which value, so if you want to represent a value with a specific number, map it yourself before pass it
        to TreeDiagramer.

    TreeDiagramingDataset:
        Arguments:
            Required: outputCol (str)
            Optional: uselessCol (list[str])=None, saveFileName (str)=None
        Will do all the magics here. Will store all the values of output column (in other word, the y-axis) in Output,
        remove the output column and useless columns (if given) from the Dataset (the Dataset will left only the needed
        input datas, in other word, the x-axis). The Dataset and Output will be fitted into TreeDgrm and the tree
        diagram will be plotted here. If saveFileName is given, the tree diagram will be saved as the filename given.

    Predict:
        Argument:
            Required: inputs (list[list[int]])
        Will use the inputs to predict. This part is also magic for me and I ain't going to explain too much here. The
        inputs will only take 2d list. It SHOULD return the predicted value(s?). The order of columns is VERY IMPORTANT.
        Should follow the order of Features.

Procedure:
    1. Preprocess the dataset first (check if there is any empty value, map the dataset if wanted to represent a
        specific value with specific number.
    2. Create an object of TreeDiagramer and pass the dataset.
    3. Can call either OneHotMapping() or Mapping() or both. DO NOT map the output column.
    4. Call TreeDiagramingDataset() and pass the output column and, if you want to save the diagram, the filename that
        you want the diagram to save as.

Notes:
    - DO NOT map the output column, especially OneHotMapping, the output should not be OneHotMappinged.
    - Mapping() and OneHotMapping() both only accept list as arguments, DO NOT use string.
    - Please make sure that there is NO empty value in the dataset.
    - When using Predict(), the order of columns is VERY IMPORTANT.
    - Predict() will only take 2d list as inputs.
    - You might want to add the changes into OneHotDataVal or DataValRepresentation.
    - The TreeDiagramer class will map using value generated by its own, if you want to use custom values then you have
        to map it manually (Which make this useless).

This code defines a class called "TreeDiagramer" that can be used to process and visualize data using a decision tree.
The class has several methods, including:

init: This is the class constructor, which is called when you create a new object of the class. It takes a single
required argument, "dataset", which should be a pandas DataFrame. The constructor initializes several properties of the
object, including "OriDataset", "Dataset", "OneHotDataVal", and "DataValRepresentation". It also sets the "Features"
property to be a list of the column names in the original dataset.

OneHotMapping: This method takes a single required argument, "columnsToApply", which should be a list of column names.
It applies one-hot encoding to the specified columns in the object's "Dataset" property, if all the values in the column
are not numeric. It stores the encoded column names in the object's "OneHotDataVal" property.

Mapping: This method takes a single required argument, "columnsToApply", which should be a list of column names. If all
the values in the specified columns are not numeric, it maps the values in those columns to integer values and stores
the mapping in the object's "DataValRepresentation" property.

TreeDiagramingDataset: This method takes a single required argument, "outputCol", which should be the name of the column
that represents the output values for the decision tree. It also has two optional arguments: "uselessCol", which should
be a list of column names that should be removed from the dataset, and "saveFileName", which should be a string
representing the file name to use when saving the resulting decision tree diagram. The method removes the specified
output and useless columns from the object's "Dataset" property, and stores the output column values in the object's
"Output" property. It then fits the remaining data in the "Dataset" property and the "Output" property into a decision
tree classifier and plots the resulting tree diagram. If the "saveFileName" argument is provided, the method also saves
the tree diagram to a file with the specified name.

Predict: This method takes a single required argument, "inputs", which should be a 2D list of integer values
representing the input data to use for prediction. It uses the input data to make predictions using the object's
"TreeDgrm" property, which is a decision tree classifier.

By: ChatGPT (2022/12/20 00:50:00)

References:
    Xavier Chee (https://drive.google.com/file/d/1G0PH7Khpb594N55_vkwDCP3TjUNpdONp/view?usp=share_link),
    w3schools (https://www.w3schools.com/python/python_ml_decision_tree.asp),
    ChatGPT
'''

import pandas as pd
import numpy as np
from sklearn.preprocessing import OneHotEncoder
from sklearn import tree
from matplotlib import pyplot as plt

class TreeDiagramer():
    def __init__(self,dataset: pd.DataFrame):
        self.OriDataset: pd.DataFrame = dataset.copy()
        self.Dataset: pd.DataFrame = dataset.copy()
        self.OneHotDataVal: dict = {}
        self.DataValRepresentation: dict = {}

        self.Features: list[str] = self.OriDataset.columns.tolist()

    def OneHotMapping(self, columnsToApply: list[str]):
        changesCol: list[str] = []
        varList: list[list[str]] = []

        for col in columnsToApply:
            if not pd.api.types.is_numeric_dtype(self.Dataset[col]):
                colNames: np.ndarray = self.Dataset[col].unique()
                encoder: OneHotEncoder = OneHotEncoder()

                changesCol.append(col)
                varList.append(colNames.tolist())

                encodedData: pd.DataFrame = pd.DataFrame(encoder.fit_transform(self.Dataset[[col]]).toarray())
                encodedData.columns = colNames

                self.Dataset = self.Dataset.join(encodedData)
                self.Dataset.drop(col, axis=1, inplace=True)

                self.Features.remove(col)
                self.Features.append(col)

        self.OneHotDataVal = dict(zip(changesCol, varList))

    def Mapping(self, columnsToApply: list[str]):
        changesCol: list[str] = []
        varDict: list[dict] = []

        for col in columnsToApply:
            if all((type(var) == bool) for var in self.Dataset[col]):
                changesCol.append(col)

                var: np.ndarray = self.Dataset[col].unique()  # Get the unique values in the pd.Series.
                changes: dict = {}

                if True in var:
                    changes.update({True: 1})
                if False in var:
                    changes.update({False: 0})

                self.Dataset[col] = self.Dataset[col].map(changes)

                varDict.append(changes)

            if not pd.api.types.is_numeric_dtype(self.Dataset[col]):  #This code uses the is_numeric_dtype function from the pandas.api.types module to check if the data type of the values in col is numeric.
                changesCol.append(col)

                var: np.ndarray = self.Dataset[col].unique()  # Get the unique values in the pd.Series.
                numVar: list[int] = list(range(len(var)))  # This will create a list with values from 0 until the number of variables of the column.

                changes: dict = dict(zip(var, numVar))
                self.Dataset[col] = self.Dataset[col].map(changes)

                varDict.append(changes)

        self.DataValRepresentation.update(dict(zip(changesCol, varDict)))

    def TreeDiagramingDataset(self, outputCol: str, uselessCol: list[str]=None, saveFileName: str=None):
        if uselessCol != None:
            self.Dataset.drop(uselessCol, axis=1, inplace=True)

            for col in uselessCol:
                self.Features.remove(col)

        if not all(pd.api.types.is_numeric_dtype(self.Dataset[col].dtype) for col in self.Dataset):
            self.Mapping(columnsToApply=self.Dataset.columns)

        self.Output: pd.Series = self.Dataset[outputCol].copy()
        self.Dataset.drop(outputCol, axis=1, inplace=True)
        self.Features.remove(outputCol)

        self.TreeDgrm: tree.DecisionTreeClassifier = tree.DecisionTreeClassifier()
        self.TreeDgrm = self.TreeDgrm.fit(self.Dataset.values, self.Output.values)

        tree.plot_tree(self.TreeDgrm, feature_names=self.Dataset.columns)

        if saveFileName != None:
            plt.savefig(saveFileName)

    def Predict(self, inputs: list[list[int]]):
        return self.TreeDgrm.predict(inputs)

if __name__ == "__main__":
    import IOIwrote as IO
    retryPredict: bool = True
    outputCol: str = "Able to join the company vacation"

    data: dict = {
        "Age": [44, 25, 27, 32, 23, 34, 33, 26, 22, 27, 45, 63, 58, 65],
        "Years worked": [10, 1, 2, 3, 0, 3, 23, 21, 3, 6, 33, 43, 41, 39],
        "Gender": ["Male", "Female", "Other", "Male", "Female", "Other", "Male", "Female", "Other", "Male", "Male", "Female", "Other", "Male"],
        "Working hour": [10, 9, 9, 11, 9.5, 9, 9, 9, 9, 1, 7, 8.5, 8, 8],
        "Able to join the company vacation": ["No", "Yes", "No", "Yes", "No", "Yes", "No", "Yes", "No", "Yes", "Yes", "No", "Yes", "No"]
    }

    df: pd.DataFrame = pd.DataFrame(data)
    obj: TreeDiagramer = TreeDiagramer(dataset=df)
    obj.OneHotMapping(columnsToApply=["Gender"])
    obj.TreeDiagramingDataset(outputCol=outputCol, saveFileName="TreeDiagram.png")

    while retryPredict == True:
        userInput: list[list] = [[]]

        for col in obj.Features:
            print(f"Column: [{col:^16}]:")

            if col in obj.OneHotDataVal:
                oneHotInput: list[int] = [0] * len(obj.OneHotDataVal[col])  #Initialize a list with size of len(obj.OneHotDataVal[col] and the values is 0.
                for i in range(len(obj.OneHotDataVal[col])):
                    print(f"Index: [{i:>3}]:[{obj.OneHotDataVal[col][i]:^16}]")

                userOneHotIndex: int = IO.ReadInt(qstStr="Input the index: ", inMin=0, inMax=len(obj.OneHotDataVal[col]) - 1)
                oneHotInput[userOneHotIndex] = 1  #Set the column corresponding to the variable to 1.
                userInput[0].extend(oneHotInput)

            elif col in obj.DataValRepresentation:
                for key, val in obj.DataValRepresentation[col].items():
                    print(f"Index: [{val:>3}]:[{key:^16}]")

                userInput[0].append(IO.ReadInt(qstStr="Input the index: ", inMin=0, inMax=len(obj.DataValRepresentation[col])))

            else:
                userInput[0].append(IO.ReadFloat(qstStr="Input: "))

        predctOutput: int = int(obj.Predict(inputs=userInput))
        predctOutputVar: str = ""

        if outputCol in obj.DataValRepresentation:
            for key, value in obj.DataValRepresentation[outputCol].items():
                if predctOutput == value:
                    predctOutputVar = key

        print(f"The prediction output is: {predctOutput} ({predctOutputVar})")

        retryPredict = IO.YNDecision(decisionStr="Try to predict again? (Y/N)\n")